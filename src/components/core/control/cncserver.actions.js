/**
 * @file Abstraction for high level action rendering, management, execution.
 */
const { Raster } = require('paper');

const actions = {}; // Exposed export.

module.exports = (cncserver) => {
  actions.projects = [];
  actions.items = [];
  actions.hashToIndex = {};

  actions.getAll = () => Object.keys(actions.hashToIndex);

  // Enumerate all valid action options.
  // TODO: This likely should follow some kind of valid formating or be
  // generated by child modules.
  actions.getOptions = () => ({
    operations: {
      fill: {
        types: {
          hatch: {
            default: true,
            settings: {

            },
          },
          pattern: {
            settings: {

            },
          },
          offset: {
            settings: {

            },
          },
        },
      },
      stroke: {
        types: {
          solid: {
            default: true,
          },
          dashed: {
            settings: {
              dashArray: [5, 5],
            },
          },
        },
      },
      text: {
        settings: cncserver.drawing.text.defaultSettings,
        fonts: cncserver.drawing.text.fonts,
      },
    },
    bounds: cncserver.drawing.base.defaultBounds(),
  });

  // Add a child job to a parent project.
  actions.addChild = (parent, payload) => {
    if (actions.hashToIndex[parent]) {
      // TODO: this.
    }
  };


  /**
   * Normalize addItem payload between allowed types given intent. Imports
   * content to "import" layer.
   *
   * @param {string} type
   *  Type of action, project or job.
   * @param {string} operation
   *  Type of operation, trace, fill, full, or vectorize.
   * @param {string|object} body
   *  Input to be normalized, usually a string, sometimes an object.
   *
   * @return {Promise}
   *  Promise that returns on success the imported & normalized input, or error
   *  on failure.
   */
  actions.normalizeInput = (type, operation, body, color) => new Promise((success, err) => {
    const { drawing: { base: { layers } } } = cncserver;
    // Draw to empty import layer.
    layers.import.activate();
    layers.import.removeChildren();

    switch (type) {
      // If a project...
      case 'project':
        // ...for trace, fill & full, body should be Paper JSON, SVG, or file.
        if (['trace', 'fill', 'full'].includes(operation)) {
          // Try to import as JSON directly.
          try {
            success(layers.import.importJSON(body));
          } catch (jsonError) {
            try {
              // Nope, JSON failed, try SVG (file or string content);
              success(layers.import.importSVG(body.trim(), {
                expandShapes: true,
                applyMatrix: true,
              }));
            } catch (svgError) {
              // Both failed!
              err(svgError);
            }
          }
        } else if (operation === 'vectorize') {
          // ...for vectorize, body must be a URL of a raster, or a file URI.
          try {
            const img = new Raster(body);
            img.onLoad = () => {
              success(img);
            };

            img.onError = err;
          } catch (imageErr) {
            // Couldn't load image.
            err(imageErr);
          }
        } else {
          err(new Error('invalid project operation'));
        }
        break;

      case 'job':
        if (['trace', 'fill', 'full'].includes(operation)) {
          try {
            const item = cncserver.drawing.base.normalizeCompoundPath(body);
            if (operation === 'trace' && !item.strokeColor) item.strokeColor = color;
            if (['fill', 'full'].includes(operation) && !item.fillColor) item.fillColor = color;
            success(item);
          } catch (pathError) {
            // Likely couldn't parse JSON import.
            err(pathError);
          }
        } else if (operation === 'text') {
          if (typeof body === 'string') {
            success(body);
          } else {
            err(new Error('text input requires a string as the body'));
          }
        } else {
          err(new Error('invalid job operation'));
        }
        break;

      default:
        break;
    }
  });

  // Manage project or job creation into tasks & instructions.
  actions.addItem = payload => new Promise((success, err) => {
    const {
      type, operation, body, clearPreview, color = 'black',
    } = payload;

    // Clear the project preview if client requests it.
    if (type === 'project' && clearPreview) {
      cncserver.drawing.base.layers.preview.removeChildren();
      cncserver.sockets.sendPaperPreviewUpdate();
    }

    // Normalize input to match expected given type & operation.
    actions.normalizeInput(type, operation, body, color)
      .then((inputContent) => {
        actions.parseWork(payload, inputContent)
          .then((item) => {
            actions.hashToIndex[item.hash] = actions.items.length;
            actions.items.push(item);
            success(item);
          })
          .catch((error) => { err(error); });
      })
      .catch((error) => { err(error); });
  });

  // Parse an incoming payload to verify its intent.
  actions.parseWork = (payload, inputContent) => new Promise((success, err) => {
    const hash = cncserver.utils.getHash(payload);
    const {
      type, parent, body, operation, bounds, settings = {}, name, color = 'black',
    } = payload;

    const item = {
      hash,
      status: 'ready',
      bounds,
      operation,
      parent,
      type,
      body,
    };

    if (type === 'job') {
      switch (operation) {
        case 'trace':
          cncserver.drawing.trace(inputContent, parent, bounds);
          success(item);
          break;

        case 'fill':
          // CLEAR the preview canvas for every job/project.
          // cncserver.drawing.base.layers.preview.removeChildren();
          cncserver.drawing.fill(inputContent, hash, null, bounds, settings);
          success(item);
          break;

        case 'text':
          settings.id = name;
          settings.color = color;
          cncserver.drawing.text.draw(inputContent, hash, null, bounds, settings);
          success(item);
          break;

        default:
          err(new Error('invalid operation'));
          break;
      }
    } else if (type === 'project') {
      if (['trace', 'fill', 'full'].includes(operation)) {
        cncserver.drawing.project.processSVG(inputContent, parent, operation, bounds, settings);
        success(item);
      } else if (operation === 'vectorize') {
        cncserver.drawing.vectorize(inputContent, hash, bounds, settings);
        success(item);
      } else {
        err(new Error('invalid operation'));
      }
    } else {
      err(new Error('invalid action type: must be job or project'));
    }
  });

  // Get a job based on the hash.
  actions.getItem = (hash) => {
    let job = null;
    const index = actions.hashToIndex[hash];
    if (index) {
      job = actions.items[index];
    }

    return job;
  };

  // Get a job based on the hash.
  actions.removeItem = (hash) => {
    let job = null;
    const index = actions.hashToIndex[hash];
    if (index) {
      job = actions.items[index];
      job.status = 'deleted';
    }
  };

  return actions;
};
